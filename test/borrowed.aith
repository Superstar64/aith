increment<>(p :: unique int*) :: unique int* {
    borrow p <A : region> {
        *p = (*p + 1)
    };
    p
}

infer(p) {
    borrow p <A : region> { () };
    p
}

inline explicitBorrow<
    B:multiplicity,
    E:multiplicity,
    G:region,
    I:boxed,
    J:representation,
    K:multiplicity,
    L:pretype<J, K>,
    M:region
> = \(f :^B <A:region> I @ A in false -* L in (M | A))
 -> \(x1 :^E unique I in G)
 -> {
    let x2 = x1;
    let e = borrow x2 <A:region>{f@_ @<A> {x2} };
    (e, x2)
};