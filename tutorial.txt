typi uses basic hindly milner for type inferance but there are polymorphic type annotations yet
typi's types:
	"boolean": boolean type
	"character": character type,utf-32, variable length encoding such as utf-8 is not supported
	"integer x": signed integer type, where x is replace with the number of bits wanted. 0 is size_t.
	"natural x": unsigned integer type
	"(& x1,x2,x3... &)": tuple type
	"x(*)": pointer type,where x is any other type
	"x[*]": array type,where x is any other type
	"x1 -> x2": function type, where x1 is the return type and x2 is the argument type
	"forall x. b": generic type
typi's expressions:
	name::value use value from other modulee 
	"123": integer literals
	"'a'": character literals
	"true","false": boolean literals
	"(x1,x2,x3,...)": tuple literals,if the amount of expressions inside the tuple literal is 1 then the tuple literal get replaced with it's one expression
	"abc": variable
	"if x1 { x2 } else { x3 }": if expression, x1 must be of bool, x2 and x3 must be the same type, x1 may require parens if it contains operations
	"while x1 { x2 }": while expression, x1 must be of bool
	"new x1": new expression,copys x1 to a new heap pointer and returns it
	"new[x1]x2": new array expression: creates an array with size x1 and inits it with x2, x1 must be of natural 0
	"cast(x2)x1": integer casting expression,x1 is an expression, x2 is a type
	"x1:x2": expression type annotation,x1 is an expression, x2 is a type
	"x1.x2": right to left function call, calls x2 with x1
	"length" : builtin length function
	"x1[x2]": array index expression,x2 must be of natural 0
	"x1(x2)": function call, functions only take 1 one argument and return 1 argument
	"x1[x2..x3]":slice expression,x2 and x3 must be of type natural 0
	"x1_t1": tuple index x1 is the tuple, t1 is the index
	math/logic binary operators(in order of precedence by row): both left and right sides must be the exact same type
		"*","/","%",
		"+","-"
		"==","!=","<=",">=","<",">",
		"&&","||",
	math/logic prefix operators:
		"-","!"
	"x1&[x2]": address of an array element
	"*x1": deference a pointer
	"x1&*_x2": if x1 is a pointer to tuple, return a pointer one of it's sub elements
	"x1 <- x2": assign a value to a pointer
	"x1 => x2": function literal, x1 is the variable name and x2 is a value. x1 maybe be a pattern match for tuples
	"x1 { x2 }": function literal
	"x1 = x2; x3": let in expression, x1 is set to x2 in x3
	"import "path" ": import a module
	"x1::x2" : access module field where x1 is a module and x2 is a field inside of a module
typi's global statements:
	"a = x" : declare a global
	"a = t" : declare a type
	"a : t; a = x" : declared a typed global
# is used for single line comments
#/ /# is used for multiline comments
