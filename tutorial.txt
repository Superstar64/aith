typi uses basic hindly milner for type inferance but there are polymorphic type annotations yet
typi's types:
	"boolean": boolean type
	"character": character type,utf-32, variable length encoding such as utf-8 is not supported
	"integer x": signed integer type, where x is replace with the number of bits wanted. 0 is size_t.
	"natural x": unsigned integer type
	"tuple(x1,x2,x3...)": tuple type, must have not length 1
	"x(*)": pointer type,where x is any other type
	"x[*]": array type,where x is any other type
	"x1 -> x2": function type, where x1 is the return type and x2 is the argument type
typi's expressions:
	name::value use value from other modulee 
	"123": integer literals
	"'a'": character literals
	"true","false": boolean literals
	"(x1,x2,x3,...)": tuple literals,if the amount of expressions inside the tuple literal is 1 then the tuple literal get replaced with it's one expression
	"abc": variable
	"if x1 then x2 else x3": if expression, x1 must be of bool, x2 and x3 must be the same type,"else x2" is optional and when it is missing it is equivalent to "()";
	"while x1 then x2": while expression, x1 must be of bool,"then x2 is optional",while will always return "()";
	"new x1": new expression,copys x1 to a new heap pointer and returns it
	"new[x1]x2": new array expression: creates an array with size x1 and inits it with x2, x1 must be of natural 0
	"(cast x2)x1": integer casting expression,x1 is an expression, x2 is a type
	"(x1:x2)": expression type annotation,x1 is an expression, x2 is a type
	"x1.x2": dot expression, right now x1 must be an array and x2 must be an "length"
	"x1[x2]": array index expression,x2 must be of natural 0
	"x1(x2)": function call, functions only take 1 one argument and return 1 argument
	"x1[x2..x3]":slice expression,x2 and x3 must be of type natural 0
	"x1_t1": tuple index x1 is the tuple, t1 is the index
	math/logic binary operators(in order of precedence by row): both left and right sides must be the exact same type
		"*","/","%",
		"+","-"
		"==","!=","<=",">=","<",">",
		"&&","||",
	math/logic prefix operators:
		"-","!"
	"x1&[x2]": address of an array element
	"*x1": deference a pointer
	"x1&_x2": if x1 is a pointer to tuple, return a pointer one of it's sub elements
	"x1 <- x2": assign a value to a pointer
	"{x1;x2;x3;...;x4}": scope expression "x"s are statements and x4 is the return value.
	">(x1) = x2": function literal, x1 is the arguments and x2 is a value.
	"import "path" ": import a module
	"x1::x2" : access module field where x1 is a module and x2 is a field inside of a module
typi's global statements:

type's local statements:
	"let x1=x2": variable decleration,declare variable x1,and assign x2 to it.
	"let x1 : type = x2"
	any expresion : must return void
typi's modules only allow:alias and let expressions global scope
# is used for single line comments
#/ /# is used for multiline comments
