digraph aith {
    // basic visualization of type system
    rankdir="BT"

    sort[label="/\\"]
    kind[label="[κ]"]
    representation
    size
    signedness

    kind -> sort
    representation -> sort
    size -> sort
    signedness -> sort
    substitutability -> sort

    type[label="*"]
    region
    pretype[label="+[κ]"]
    boxed[label="-"]
    capacity[label="capacity"]
    pointerRep[label="pointer"]
    structRep[label="struct (κ, κ', ...)"]
    wordRep[label="κ word"]
    byte [label="8bit"]
    short [label="16bit"]
    int [label="32bit"]
    long [label="64bit"]
    signed
    unsigned

    type -> kind
    region -> kind
    pretype -> kind
    boxed -> kind
    pointerRep -> representation
    structRep -> representation
    wordRep -> representation
    byte -> size
    short -> size
    int -> size
    long -> size
    signed -> signedness
    unsigned -> signedness
    capacity -> kind
    invariant -> substitutability
    subtypable -> substitutability


    inline[label="σ -> τ"]
    poly[label="<...> σ"]
    ofCourse[label="!σ"]
    functionPointer[label="function*(σ) => τ uses π"]
    functionLiteralType[label="function(σ) => τ uses π"]
    pair[label="(σ, τ)"]
    unit[label="()"]
    effect[label="σ in π"]
    unique[label="unique σ"]
    shared[label="σ @ π"]
    pointer[label="σ[τ]"]
    number[label="κ integer(κ)'"]
    boolean[label="bool"]
    world[label="io"]
    unknown[label=":"]

    inline -> type
    poly -> type
    ofCourse -> type
    functionPointer -> pretype
    functionPointer -> pointerRep [style=dashed]
    functionLiteralType -> type
    pair -> pretype
    pair -> structRep[style=dashed]
    unit -> pretype
    unit -> structRep[style=dashed]
    effect -> type
    unique -> pretype
    unique -> pointerRep[style=dashed]
    shared -> pretype
    shared -> pointerRep[style=dashed]
    pointer -> boxed
    number -> pretype
    number -> wordRep[style=dashed]
    boolean -> pretype
    boolean -> wordRep[style=dashed]
    world -> region
    unknown -> capacity

    let[label="let x = e; e'"]
    extern[label="extern \"sym\""]
    app[label="e (e')"]
    pairIntro[label="(e,e')"]
    unitIntro[label="()"]
    read[label="*e"]
    write[label="*e = e'"]
    num[label="n"]
    arith[label="e + e'"]
    relate[label="e < e'"]
    true
    if[label="if e {e'} else {e''}"]

    functionLiteral[label="function(x) { e }"]
    inlineAbstraction[label="\\x => e"]
    ofCourseIntro[label="!e"]
    polyIntroduction[label="<...> e"]

    


    let -> effect
    extern -> effect
    extern -> functionPointer[style=dashed]
    app -> effect
    pairIntro -> effect
    pairIntro -> pair [style=dashed]
    unitIntro -> effect
    unitIntro -> unit [style=dashed]
    read -> effect
    write -> effect
    write -> unit[style=dashed]
    num -> effect
    num -> number[style=dashed]
    arith -> effect
    arith -> number[style=dashed]
    relate -> effect
    relate -> boolean[style=dashed]
    true -> effect
    true -> boolean[style=dashed]
    if -> effect

    functionLiteral -> functionLiteralType
    inlineAbstraction -> inline
    ofCourseIntro -> ofCourse
    polyIntroduction -> poly
}