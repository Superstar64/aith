digraph aith {
    // basic visualization of type system
    rankdir="BT"
    
    {
        // sorts
        rank=same
        kindInvTrans[label="kind invariant transparent"]
        kindInvOpa[label="kind invariant opaque"]
        kindSubTrans[label="kind subtypable transparent"]
        kindSubOpa[label="kind subtypable opaque"]
    }

    {
        // kinds
        rank=same
        type[label="type"]
        region
        pretype[label="pretype<κ, κ'>"]
        boxed[label="boxed"]
        representation
        size
        signedness
        multiplicity
    }

    type -> kindInvTrans
    region -> kindSubTrans
    pretype -> kindInvTrans
    boxed -> kindInvTrans
    pointerRep -> representation
    structRep -> representation
    wordRep -> representation
    byte -> size
    short -> size
    int -> size
    long -> size
    signed -> signedness
    unsigned -> signedness
    representation -> kindInvOpa
    size -> kindInvOpa
    signedness -> kindInvOpa
    multiplicity -> kindSubTrans

    {
        // types
        rank=same
        inline[label="σ -> τ"]
        poly[label="<...> σ"]
        ofCourse[label="!σ"]
        functionPointer[label="function*(σ) => τ uses π"]
        functionLiteralType[label="function(σ) => τ uses π"]
        tuple[label="(σ, τ, ...)"]
        effect[label="σ in π"]
        unique[label="unique σ"]
        shared[label="σ @ π"]
        pointer[label="σ[τ]"]
        number[label="κ integer(κ)'"]
        boolean[label="bool"]
        world[label="io"]
        unknown[label=":"]
        pointerRep[label="pointer"]
        structRep[label="struct (κ, κ', ...)"]
        wordRep[label="κ word"]
        byte [label="8bit"]
        short [label="16bit"]
        int [label="32bit"]
        long [label="64bit"]
        signed
        unsigned
        linear
        unrestricted
    }

    inline -> type
    poly -> type
    ofCourse -> type
    functionPointer -> pretype
    functionPointer -> pointerRep [color=lightcoral]
    functionLiteralType -> type
    tuple -> pretype
    tuple -> structRep[color=lightgreen]
    effect -> type
    unique -> pretype
    unique -> pointerRep[color=lightcoral]
    shared -> pretype
    shared -> pointerRep[color=lightcoral]
    pointer -> boxed
    number -> pretype
    number -> wordRep[color=lightblue]
    boolean -> pretype
    boolean -> wordRep[color=lightblue]
    world -> region
    unknown -> capacity
    linear -> multiplicity
    unrestricted -> multiplicity

    {
        // terms
        rank=same
        let[label="let x = e; e'"]
        extern[label="extern \"sym\""]
        app[label="e (e')"]
        tupleIntro[label="(e,e', ...)"]
        read[label="*e"]
        write[label="*e = e'"]
        num[label="n"]
        arith[label="e + e'"]
        relate[label="e < e'"]
        true
        if[label="if e {e'} else {e''}"]

        functionLiteral[label="function(x) { e }"]
        inlineAbstraction[label="\\x => e"]
        ofCourseIntro[label="!e"]
        polyIntroduction[label="<...> e"]
    }
    


    let -> effect
    extern -> effect
    extern -> functionPointer[color=lavender]
    app -> effect
    tupleIntro -> effect
    tupleIntro -> tuple [color=lavender]
    read -> effect
    write -> effect
    write -> tuple[color=lavender]
    num -> effect
    num -> number[color=lavender]
    arith -> effect
    arith -> number[color=lavender]
    relate -> effect
    relate -> boolean[color=lavender]
    true -> effect
    true -> boolean[color=lavender]
    if -> effect

    functionLiteral -> functionLiteralType
    inlineAbstraction -> inline
    ofCourseIntro -> ofCourse
    polyIntroduction -> poly
}
