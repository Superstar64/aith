digraph aith {
    rankdir="BT"
    concentrate=true;

    // unabstractable types
    top

    unification
    transparency
    label[label="label"]

    unification -> top
    transparency -> top
    label -> top

    transparent
    opaque
    syntactic
    propositional

    transparent -> transparency
    opaque -> transparency
    syntactic -> unification
    propositional -> unification
    ambiguous -> label
    
    subgraph cluster_kind{
        bgcolor=lightgray; peripheries=0
        kindInvTrans[label="kind<syntatic, transparent>"]
        kindSubTrans[label="kind<propositional, transparent>"]
        kindInvOpa[label="kind<syntatic, opaque>"]
    } -> top
    representation
    size
    multiplicity[label="multiplicity"]

    representation -> kindInvOpa
    size -> kindInvOpa
    multiplicity -> kindSubTrans
    type[label="type"]
    boxed[label="boxed"]
    region
    pointerRep[label="pointer"]
    structRep[label="struct (κ, κ', ...)"]
    wordRep[label="κ word"]
    byte [label="8bit"]
    short [label="16bit"]
    int [label="32bit"]
    long [label="64bit"]
    signedness
    linear
    unrestricted

    subgraph cluster_pretype {
        bgcolor=lightgray; peripheries=0
        pretype[label="pretype<κ, κ'>"]
        pretypePtrU[label="pretype<pointer,unrestricted>"]
        pretypePtrL[label="pretype<pointer,linear>"]
        pretypeWord[label="pretype<κ word, unrestricted>"]
        pretypeStruct[label="pretype<struct(...), κ>"]
    } -> kindInvTrans

    type -> kindInvTrans
    boxed -> kindInvTrans
    region -> kindSubTrans
    pointerRep -> representation
    structRep -> representation
    wordRep -> representation
    byte -> size
    short -> size
    int -> size
    long -> size
    signedness -> kindInvOpa
    linear -> multiplicity
    unrestricted -> multiplicity


    inline[label="σ -[π]> τ"]
    poly[label="<...> σ"]
    functionPointer[label="function*(σ) => τ uses π"]
    functionLiteralType[label="function(σ) => τ uses π"]
    tuple[label="(σ, τ, ...)"]
    unique[label="unique σ"]
    shared[label="σ @ π"]
    pointer[label="σ*"]
    array[label="σ[]"]
    number[label="σ integer(τ)"]
    boolean[label="bool"]
    world[label="io"]
    signed
    unsigned
    subgraph cluster_effect {
        bgcolor=lightgray; peripheries=0
        effect[label="σ in π"]
        effectFunction[label="function*(σ) => τ uses μ in π"]
        effectTuple[label="(σ, τ, ...) in π"]
        effectNumber[label="σ integer(τ) in π"]
        effectBoolean[label="bool in π"]
    } -> type

    inline -> type
    poly -> type
    functionPointer -> pretypePtrU
    functionLiteralType -> type
    tuple -> pretypeStruct
    unique -> pretypePtrL
    shared -> pretypePtrU
    pointer -> boxed
    array -> boxed
    number -> pretypeWord
    boolean -> pretypeWord
    world -> region
    signed -> signedness
    unsigned -> signedness

    let[label="let x = e; e'"]
    extern[label="extern \"sym\""]
    app[label="e (e')"]
    tupleIntro[label="(e,e', ...)"]
    read[label="*e"]
    write[label="*e = e'"]
    num[label="n"]
    arith[label="e + e'"]
    relate[label="e < e'"]
    true
    if[label="if e {e'} else {e''}"]

    functionLiteral[label="function(x) { e }"]
    inlineAbstraction[label="\\x => e"]
    polyIntroduction[label="<...> e"]


    let -> effect
    extern -> effectFunction
    app -> effect
    tupleIntro -> effectTuple
    read -> effect
    write -> effectTuple
    num -> effectNumber
    arith -> effectNumber
    relate -> effectBoolean
    true -> effectBoolean
    if -> effect
    functionLiteral -> functionLiteralType
    inlineAbstraction -> inline
    polyIntroduction -> poly
}
