\documentclass {article}
\usepackage{mathtools}
\usepackage{hyperref}
\allowdisplaybreaks
\begin{document}

\tableofcontents


\section{Main Language}

All valid terms have a type who's kind is of the form $ \text{Type} (\kappa) $. \\
\\
All valid types have a kind who's sort is of the form $ \text{Kind} $.\\
\\
Function literals and function literal types can not appear at runtime. They must be bound by a global "function" binding.
This binding converts a function literal into an extern and a function literal type into a function pointer type. \\
\\
Treat all terms with a type of kind $ \text{Type} (\text{Runtime} (\rho)) $ as if they are already is $ \beta $ normal form. \\
\\
Reduction of $ \Lambda \alpha : \kappa. e $ and $ \lambda^\wedge x : \sigma. e $ may occur inside a term with a type of kind $ \text{Type} (\text{Runtime} (\rho)) $, but they don't
change the term's code generation. \\
\\
After $ \beta $ reduction, terms with no free variables and of with a type not of kind $ \text{Type} (\text{Runtime} (\rho) ) $ must corrispond with these types. \\
\\

\begin{gather*}
\begin{array}{c | c}
\text{Type} & \text{Term} \\
\hline
\sigma \to \tau & \lambda x : \sigma. e \\
!\sigma & !e \\
\forall \alpha : \kappa. \sigma & \Lambda \alpha : \kappa. e  \\
\forall \beta : \mu. \sigma & \Lambda \beta : \mu. e \\
\sigma \xrightarrow{\text{text}} \tau & \text{function}(x : \sigma). e \\
\pi \xrightarrow{\wedge} \sigma & \lambda^\wedge x : \sigma. e
\end{array}
\\
\end{gather*}
$ RT (\sigma) $ and is shorthand for $ \Phi \vdash \sigma : \text{Type} (\text{Runtime} (\text{Data}, \text{Real} ((\kappa))) $ with a unique $ \kappa $ \\

\subsection{Object Categories}

\begin{align*}
e \tag{Terms} \\
x \tag{Variables} \\
n \tag{Numbers} \\
\sigma, \tau \tag{Types} \\
\alpha \tag{Type Variables} \\
\kappa, s, \rho \tag{Kinds} \\
\beta \tag{Kind Variables} \\
\mu \tag{Sorts} \\
\Gamma \tag{Type Environment} \\
\Phi \tag{Misc Environment} \\
\text{sym} \tag{Symbol}
\end{align*}


\subsection{Judgment Forms}
Term checking uses the checking direction from bidirectional type checking.
Type and Kind checking uses synthesis mode.
\begin{align*}
\Phi \mid \Gamma \vdash \, & e : \sigma \tag{\text{Term Validation}} \\
\Phi \vdash \, & \sigma : \kappa \tag{\text{Type Validation}} \\
\Phi \vdash \, & \kappa : \mu \tag{Kind Validation} \\
\end{align*}

\subsection{Typing Environments}
\begin{align*}
\Gamma \Coloneqq & \\
& \Gamma, [x : \sigma] \\
& \Gamma, \langle x : \sigma \rangle \\
& \emptyset \\
\Phi \Coloneqq & \\
& \Phi, \alpha : \kappa \\
& \Phi, \beta : \mu \\
& \emptyset \\
\end{align*}

\subsection{Meta}
\begin{align*}
\kappa, s, \rho \Coloneqq & \\
& \text{Type} (s) \tag{Type} \\
\mu \Coloneqq & \\
& \text{Kind} \\
& \text{Stage} \\
\end{align*}

\begin{gather*}
\frac
{\Phi \vdash s : \text{Stage}}
{\Phi \vdash \text {Type} (s) : \text{Kind}} \\
\end{gather*}


\subsubsection{Variables}
\begin{align*}
e \Coloneqq & \\
& x \tag{Variable} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \alpha \tag{Type Variable} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \beta \tag{Kind Variable} \\
& \dots
\end{align*}

\begin{gather*}
\Phi | \langle x : \sigma \rangle \vdash x : \sigma \\
\\
\Phi | [ x : \sigma ] \vdash x : \sigma \\
\\
\frac
{\Phi | \Gamma, \Gamma' \vdash e : \sigma}
{\Phi | \Gamma', \Gamma \vdash e : \sigma} \\
\\
\frac
{\Phi | \Gamma \vdash e : \sigma}
{\Phi | \Gamma, [ x : \tau ] \vdash e : \sigma } \\
\\
\frac
{\Phi | \Gamma, [x : \tau], [x : \tau] \vdash e : \sigma}
{\Phi | \Gamma, [x : \tau] \vdash e : \sigma } \\
\end{gather*}

\begin{gather*}
\frac
{(\alpha : \kappa) \in \Phi}
{\Phi \vdash \alpha : \kappa}
\end{gather*}

\begin{gather*}
\frac
{(\beta : \mu) \in \Phi}
{\Phi \vdash \beta : \mu } \\
\end{gather*}

\subsubsection{Macro Linear Lambda Calculus}
\begin{align*}
e \Coloneqq & \\
& \lambda x. e \tag{Macro Lambda}\\
& e(e') \tag{Macro Application}\\
& !e \tag{Bang Introduction} \\
& \text{let} \, !(x : \sigma) = e; e' \tag{Bang Elimination} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \sigma \to \tau \tag{Macro} \\
& !\sigma \tag{Bang} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Meta} \tag{Meta Stage} \\
\dots
\end{align*}

\begin{gather*}
\frac
{\Phi | \Gamma, \langle x : \sigma \rangle \vdash e : \tau}
{\Phi | \Gamma \vdash \lambda x. e : \sigma \to \tau } \\
\\
\frac
{\Phi | \Gamma \vdash e_1 : \sigma \to \tau \quad \Phi | \Gamma' \vdash e_2 : \sigma \quad \Phi \vdash \sigma : \text{Type} (\kappa)}
{\Phi | \Gamma, \Gamma' \vdash e_1(e_2 : \sigma) : \tau} \\
\\
\frac
{\Phi | \Gamma \vdash e : \sigma \quad \langle x : \tau \rangle \notin \Gamma }
{\Phi | \Gamma \vdash !e : !\sigma } \\
\\
\frac
{\Phi | \Gamma \vdash e : !\tau \quad \Phi | \Gamma', [x : \tau] \vdash e' : \sigma \quad \Phi \vdash \tau : \text{Type} (\kappa) }
{\Phi | \Gamma, \Gamma' \vdash \text{let} \, !(x : \tau) = e; e' : \sigma}  \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \sigma : \text{Type} (s) \quad \Phi \vdash \tau : \text{Type} (s')}
{\Phi \vdash \sigma \to \tau : \text{Type} (\text{Meta})} \\
\\
\frac
{\Phi \vdash \sigma : \text{Type} (s)}
{\Phi \vdash !\sigma : \text{Type} (\text{Meta})} \\
\end{gather*}

\begin{gather*}
\frac
{}
{\Phi \vdash \text{Meta} : \text{Stage}} \\
\end{gather*}

\subsubsection{System-F}
\begin{align*}
e \Coloneqq & \\
& \Lambda \alpha. e \tag{Type Lambda} \\
& (e : \forall \alpha. \tau) \sigma \tag{Type Application} \\
& \Lambda \beta. e \tag{Kind Lambda} \\
& (e : \forall \beta. \tau) \kappa \tag{Kind Application} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \forall \alpha : \kappa. \sigma \tag{Type Forall}\\ 
& \forall \beta : \mu. \sigma \tag{Kind Forall}\\
& \dots
\end{align*}

\begin{gather*}
\frac
{\Phi, \alpha : \kappa | \Gamma \vdash e : \sigma}
{\Phi | \Gamma \vdash \Lambda \alpha. e : \forall \alpha : \kappa. \sigma } \\
\\
\frac
{\Phi | \Gamma \vdash e : \forall \alpha : \kappa. \sigma \quad \Phi \vdash \tau : \kappa }
{\Phi | \Gamma \vdash (e : \forall \alpha. \sigma) \tau : \sigma [\tau/\alpha] } \\
\\
\frac
{\Phi, \beta : \mu | \Gamma \vdash e : \sigma}
{\Phi | \Gamma \vdash \Lambda \beta. e : \forall \beta : \mu. \sigma} \\
\\
\frac
{\Phi | \Gamma \vdash e : \forall \beta : \mu. \sigma \quad \Phi \vdash \kappa : \mu}
{\Phi | \Gamma \vdash (e : \forall \beta. \sigma) \kappa : \sigma [\kappa/\beta]} \\
\end{gather*}

\begin{gather*}
\frac
{\Phi, \alpha : \kappa \vdash \sigma : \text{Type}(s) \quad \Phi \vdash \kappa : \text{Kind}}
{\Phi \vdash \forall \alpha : \kappa. \sigma : \text{Type} (s) } \\
\\
\frac
{\Phi, \beta : \mu \vdash \sigma : \text{Type} (s) \quad \Phi \vdash \mu  }
{\Phi \vdash \forall \beta : \mu. \sigma : \text{Type} (\text{Meta}) } \\
\end{gather*}

\subsubsection{Evidence Passing}
\begin{align*}
e \Coloneqq & \\
& \lambda^\wedge x. e \tag{Evidence Lambda} \\
& e (^\wedge e' : \pi) \tag{Evidence Application} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \pi \xrightarrow{\wedge} \sigma \tag{Evidence Function} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Evidence} \tag{Evidence Stage} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{\Phi | \Gamma, [x : \pi] \vdash e : \sigma}
{\Phi | \Gamma \vdash \lambda^\wedge x. e : \pi \xrightarrow{\wedge} \sigma} \\
\\
\frac
{\Phi | \Gamma \vdash e : \pi \xrightarrow{\wedge} \sigma \quad \Phi | \Gamma' \vdash e': \pi  \quad \Phi \vdash \pi : \text{Text}(\text{Evidence})}
{\Phi | \Gamma, \Gamma' \vdash e (^\wedge e' : \pi) : \sigma}
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \pi : \text{Type}(\text{Evidence}) \quad \Phi \vdash \sigma : \text{Type}(s)}
{\Phi \vdash \pi \xrightarrow{\wedge} \sigma : \text{Type}(s)} \\
\end{gather*}

\begin{gather*}
\frac
{}
{\Phi \vdash \text{Evidence} : \text{Stage}} \\
\end{gather*}

\subsection{Runtime}

\begin{align*}
\kappa, s, \rho \Coloneqq & \\
& \text{Runtime} (\rho, \rho') \tag{Runtime Stage}\\
& \text{Code} \tag{Code Impact}\\
& \text{Data} \tag{Data Impact}\\
& \text{Real} (\rho) \tag{Real Existance} \\
& \text{Imaginary} \tag{Imaginary Existance} \\
& \text{Pointer} \tag{Pointer Representation}\\
& \dots \\
\mu \Coloneqq & \\
& \text{Impact} \\
& \text{Existance} \\
& \text{Representation} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{\Phi \vdash \rho : \text{Impact} \quad \Phi \vdash \rho' : \text{Existance}}
{\Phi \vdash \text{Runtime} (\rho, \rho') : \text{Stage}} \\
\\
\frac
{}
{\Phi \vdash \text{Code} : \text{Impact}} \\
\\
\frac
{}
{\Phi \vdash \text{Data} : \text{Impact}} \\
\\
\frac
{\Phi \vdash \rho : \text{Representation}}
{\Phi \vdash \text{Real} (\rho) : \text{Existance}} \\
\\
\frac
{}
{\Phi \vdash \text{Imaginary} : \text{Existance}} \\
\end{gather*}

\begin{gather*}
\end{gather*}

\subsubsection{Functions}

\begin{align*}
e \Coloneqq & \\
& \text{extern} \, \text{sym} \tag{Extern Function} \\
& e(^\star e' : \sigma) \tag{Function Pointer Application} \\
& \text{function} (x). e \tag{Function Literal} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \tau \xrightarrow{\star} \sigma \tag{Function Pointer}\\
& \tau \xrightarrow{\text{text}} \sigma  \tag{Function Literal Type} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Text} \tag{Symbol Stage} \\
\end{align*}

\begin{gather*}
\frac
{}
{\Phi | \Gamma \vdash \text{extern} \, \text{sym} : \tau \xrightarrow{\star} \sigma} \\
\\
\frac
{\Phi | \Gamma \vdash e : \sigma \xrightarrow{\star} \tau \quad \Phi | \Gamma' \vdash e' : \sigma \quad \text{RT}(\sigma) \quad \Phi \vdash \tau : \text{Type} (\text{Runtime} (\rho, \rho'))}
{\Phi | \Gamma, \Gamma' \vdash e(^\star e' : \sigma) : \tau} \\
\\
\frac
{\Phi | \Gamma, \langle x : \sigma \rangle \vdash e : \tau}
{\Phi | \Gamma \vdash \text{function}(x). e : \sigma \xrightarrow{\text{text}} \tau} \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \sigma : \text{Type} (\text{Runtime} (\text{Data}, \text{Real} (\rho''))) \quad \Phi \vdash \tau : \text{Type} (\text{Runtime} (\rho, \rho'))}
{\Phi \vdash \sigma \xrightarrow{\star} \tau : \text{Type} (\text{Runtime} (\text{Data}, \text{Real} ( \text{Pointer})))} \\
\\
\frac
{\Phi \vdash \sigma : \text{Type} (\text{Runtime} (\text{Data}, \text{Real}( \rho' ))) \quad \Phi \vdash \tau : \text{Type} (\text{Runtime} (\rho, \rho'))}
{\Phi \vdash \sigma \xrightarrow{\text{text}} \tau : \text{Type} (\text{Text})} \\
\end{gather*}


\begin{gather*}
\frac
{}
{\Phi \vdash \text{Text} : \text{Stage}} \\
\end{gather*}

\subsubsection{Bindings}
\begin{align*}
e \Coloneqq & \\
& \text{let}^\star \, (x : \tau) = e; e' \tag{Runtime Let} \\
& \text{copy} \, (x : \tau) =^{e''} e; e' \tag{Runtime Copy Let} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{\splitfrac{ \Phi | \Gamma \vdash e : \tau \quad \Phi | \Gamma', \langle x : \tau \rangle \vdash e' : \sigma}
{\text{RT}(\tau) \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\rho, \rho')) }}
{\Phi | \Gamma, \Gamma' \vdash \text{let}^\star \, (x : \tau) = e; e' : \sigma} \\
\\
\frac
{\splitfrac{ \Phi | \Gamma \vdash e : \tau \quad \Phi | \Gamma', [ x : \tau ] \vdash e' : \sigma}
{\splitfrac{\text{RT}(\tau) \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\rho, \rho')) }
{\Phi | \Gamma'' \vdash e'' : \text{Copy}(\tau)}}
}
{\Phi | \Gamma, \Gamma', \Gamma'' \vdash \text{copy} \, (x : \tau) =^{e''} e; e' : \sigma} \\
\end{gather*}

\begin{gather*}
\end{gather*}


\subsubsection{Pair}
\begin{align*}
e \Coloneqq & \\
& (^\star e, e') \tag{Runtime Pair Introduction} \\
& \text{let}^\star (x : \tau, x' : \tau') = e; e' \tag{Runtime Pair Elimination} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& (^\star \sigma, \tau) \tag{Runtime Pair} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Structure} \{ \rho, \rho', \dots \} \tag{Structure Representation} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{\Phi | \Gamma \vdash e : \sigma \quad \Phi | \Gamma' \vdash e' : \tau}
{\Phi | \Gamma, \Gamma' \vdash (^\star e, e') : (^\star \sigma, \tau) } \\
\\
\frac
{\splitfrac{\Phi | \Gamma \vdash e : (^\star \tau, \tau') \quad \Phi | \Gamma , \langle x : \tau \rangle, \langle x' : \tau' \rangle \vdash e : \sigma  }
{\text{RT}(\tau) \quad \text{RT}(\tau') \quad \Phi \vdash \sigma : \text{Type} (\text{Runtime} (\rho, \rho')) }}
{\Phi | \Gamma, \Gamma' \vdash \text{let}^\star (x : \tau, x' : \tau') = e; e' : \sigma}
\end{gather*}

\begin{gather*}
\frac
{\splitfrac{\Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \text{Real}(\kappa)))}
{\Phi \vdash \tau : \text{Type} (\text{Runtime}(\text{Data}, \text{Real} (\kappa'))) }}
{\Phi \vdash (^\star \sigma, \tau) : \text{Type} (\text{Runtime} (\text{Data}, \text{Real} (\text{Structure} \{ \kappa,\kappa'\} )))} \\
\end{gather*}


\begin{gather*}
\frac
{\Phi \vdash \rho : \text{Representation} \quad \Phi \vdash \rho' : \text{Representation} \quad \dots}
{\Phi \vdash \text{Structure} \{ \rho, \rho', \dots \} : \text{Representation} } \\
\end{gather*}

\subsubsection{Monadic Regions}
\begin{align*}
e \Coloneqq & \\
& \text{pure} \, e \tag{Pure Region Transformer}\\
& \text{do} \, (x : \tau) = e; e' \tag{Bind Region Transformer} \\
& \text{letRGN} \, (\Lambda \alpha \lambda^\wedge x. e) \tag{Create Region} \\
& \text{envRGN} \, \pi \, e \, e' \tag{Subtype Region} \\
& \text{runRGN} (\Lambda \alpha. e) \tag{Evaluate Region} \\
& \text{readRGNLoc} \, e' \, e \tag{Dereference Pointer} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \text{RGN} \pi \sigma \tag{Region Transformer} \\
& \text{RGNLoc} \pi \sigma \tag{Reference} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Region} \tag{Region} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{\Phi | \Gamma \vdash e : \sigma }
{\Phi | \Gamma \vdash \text{pure} \, e : \text{RGN} \pi \sigma } \\
\\
\frac
{\Phi | \Gamma \vdash e : \text{RGN} \pi \sigma \quad \Phi | \Gamma', \langle x : \sigma \rangle \vdash e' : \text{RGN} \pi \tau \quad \text{RT}(\sigma) }
{\Phi | \Gamma, \Gamma' \vdash \text{do} \, (x : \sigma) = e; e' : \text{RGN} \pi \tau} \\
\\
\frac
{\Phi , \alpha : \text{Region} | \Gamma, [x : \pi \preceq \alpha] \vdash e : \text{RGN} \alpha \sigma \quad \alpha \notin \text{Free}(\sigma, \pi)}
{\Phi | \Gamma \vdash \text{letRGN} \, (\Lambda \alpha \lambda^\wedge x. e) : \text{RGN} \pi \sigma} \\
\\
\frac
{\Phi | \Gamma \vdash e : \text{RGN} \pi \sigma \quad \Phi | \Gamma' \vdash e' : \pi \preceq \pi' \quad \Phi \vdash \pi : \text{Region}}
{\Phi | \Gamma, \Gamma' \vdash \text{envRGN} \pi \, e' \, e : \text{RGN} \pi' \sigma } \\
\\
\frac
{\Phi, \alpha : \text{Region}| \Gamma \vdash e : \text{RGN} \alpha \sigma \quad \alpha \notin \text{Free}(\sigma) \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \rho)}
{\Phi | \Gamma \vdash \text{runRGN} (\Lambda \alpha. e) : \sigma}\\
\\
\frac
{\Phi | \Gamma \vdash e : \text{RGNLoc} \pi \sigma \quad \Phi | \Gamma' \vdash e' : \text{Copy} (\sigma) \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \text{Real}(\rho))) }
{\Phi | \Gamma, \Gamma' \vdash \text{readRGNLoc} \, e' \, e : \text{RGN} \pi \sigma} \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \pi : \text{Region} \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \rho))}
{\Phi \vdash \text{RGN} \pi \sigma : \text{Type}(\text{Runtime}(\text{Code}, \rho))} \\
\\
\frac
{\Phi \vdash \pi : \text{Region} \quad \Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \text{Real}(\rho)))}
{\Phi \vdash \text{RGNLoc} \pi \sigma : \text{Type}(\text{Runtime} (\text{Data}, \text{Real}(\text{Pointer})))} \\
\end{gather*}


\begin{gather*}
\frac
{}
{\Phi \vdash \text{Region} : \text{Kind}} \\
\frac
{}
{\Phi \vdash \text{Pointer} : \text{Representation}} \\
\end{gather*}

\subsubsection{Integer Arithmatic}
\begin{align*}
e \Coloneqq & \\
& n \tag{Numeric Literal} \\
& e + e' \tag{Addition} \\
& e - e' \tag{Subtraction} \\
& e * e' \tag{Multiplication} \\
& e / e' \tag{Division} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \text{Number} (\rho, \rho) \tag{Number} \\
& \dots \\
\kappa, s, \rho \Coloneqq & \\
& \text{Word} (\rho) \tag{Word Representation} \\
& 8 \tag{Byte Size} \\
& 16 \tag{Short Size} \\
& 32 \tag{Int Size} \\
& 64 \tag{Long Size} \\
& \text{signed} \tag{Signed} \\
& \text{unsigned} \tag{Unsigned} \\
& \dots \\
\mu \Coloneqq & \\
& \text{Size} \\
& \text{Signedness} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{}
{\Phi | \Gamma \vdash n : \text{Number}(\rho, \rho')} \\
\\
\frac
{\Phi | \Gamma \vdash e : \text{Number}(\rho, \rho') \quad \Phi | \Gamma, \Gamma' \vdash e' : \text{Number}(\rho, \rho')}
{\Phi | \Gamma, \Gamma' \vdash e + e' : \text{Number}(\rho, \rho')} \\
\dots
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \rho : \text{Signedness} \quad \Phi \vdash \rho' : \text{Size}}
{\Phi \vdash \text{Number} (\rho, \rho') : \text{Type} (\text{Runtime} (\text{Data}, \text{Real} (\text{Word} (\rho')))) } \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \rho : \text{Size}}
{\Phi \vdash \text{Word} (\rho) : \text{Representation}} \\
\\
\frac
{}
{\Phi \vdash 8 : \text{Size}} \\
\\
\frac
{}
{\Phi \vdash 16 : \text{Size}} \\
\\
\frac
{}
{\Phi \vdash 32 : \text{Size}} \\
\\
\frac
{}
{\Phi \vdash 64 : \text{Size}} \\
\\
\frac
{}
{\Phi \vdash \text{signed} : \text{Signedness}} \\
\\
\frac
{}
{\Phi \vdash \text{unsigned} : \text{Signedness}} \\
\end{gather*}


\subsubsection{Copy Evidence}
\begin{align*}
e \Coloneqq & \\
& \text{copy}^\text{Int} \tag{Copy Integer Proof} \\
& \text{copy}^{\to^\star} \tag{Copy Function Pointer Proof} \\
& \text{copy}^{\star(,)} \, e \, e' \tag{Copy Tuple Proof} \\
& \text{copy}^{\text{RGNLoc}} \tag{Copy Reference Proof}\\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \text{Copy} \, \sigma \tag{Runtime Copyable} \\
\end{align*}

\begin{gather*}
\frac
{}
{\Phi | \Gamma \vdash \text{copy}^\text{Int}  : \text{Copy} (\text{Number} (\rho, \rho'))} \\
\\
\frac
{}
{\Phi | \Gamma \vdash \text{copy}^{\to\star} : \text{Copy} (\sigma \to^\star \tau)} \\
\\
\frac
{\Phi | \Gamma \vdash e : \text{Copy} (\sigma) \quad \Phi | \Gamma \vdash e' : \text{Copy} (\tau)}
{\Phi | \Gamma, \Gamma' \vdash \text{copy}^{\star(,)} \, e \, e' : \text{Copy} ((^\star\sigma, \tau))} \\
\\
\frac
{}
{\Phi | \Gamma \vdash \text{copy}^\text{RGNLoc} : \text{Copy} (\text{RGNLoc} \pi \sigma)} \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \sigma : \text{Type}(\text{Runtime}(\text{Data}, \text{Real}(\rho)))}
{\Phi \vdash \text{Copy} \, \sigma : \text{Type}(\text{Evidence})} \\
\end{gather*}


\subsubsection{Region Evidence}
\begin{align*}
e \Coloneqq & \\
& \text{id}^\preceq \tag{SubType Identity Proof} \\
& e \circ^\preceq \pi e' \tag{SubType Compose Proof} \\
& \dots \\
\sigma, \tau, \pi \Coloneqq & \\
& \pi \preceq \pi' \tag{Region Scoping} \\
& \dots
\end{align*}

\begin{gather*}
\frac
{}
{\Phi | \Gamma \vdash \text{id}^{\preceq}  : \pi \preceq \pi} \\
\\
\frac
{\Phi | \Gamma \vdash e : \pi' \preceq \pi'' \quad \Phi | \Gamma' \vdash e' : \pi \preceq \pi' \quad \Phi \vdash \pi' : \text{Region}}
{\Phi | \Gamma, \Gamma' \vdash e \circ^\preceq \pi e' : \pi \preceq \pi''} \\
\end{gather*}

\begin{gather*}
\frac
{\Phi \vdash \pi : \text{Region} \quad \Phi \vdash \pi' : \text{Region}}
{\Phi \vdash \pi \preceq \pi' : \text{Type}(\text{Evidence})} \\
\end{gather*}

\section{Simple Language}
The is the internal intermediate language used before C code generation.
Like terms in the main language, this is typechecked in checking mode.
\begin{align*}
e \Coloneqq & \\
& x \\
& \text{let} \, x : \sigma = e; e' \\
& \text{extern} \, \text{sym} \, \sigma \to \tau \\
& e(e' : \tau) : \sigma \\
& (e,e') \\
& \text{let} (x: \sigma, x' : \sigma') = e; e' \\
& \star e \\
& n \\
& e +^z e' \\
\sigma \Coloneqq & \\
& \text{void}\star \\ 
& (\sigma, \sigma', \dots) \\
& \text{word} \, s \\
s \Coloneqq & \, \text{char} \, | \, \text{short} \, | \, \text{int} \, | \, \text{long} \\
z \Coloneqq & \, \text{signed} \, | \, \text{unsigned}
\end{align*}

\begin{gather*}
\frac
{(x : \sigma) \in \Gamma}
{\Gamma \vdash x : \sigma} \\
\\
\frac
{\Gamma \vdash x : \sigma \quad \Gamma, x : \sigma \vdash e' : \tau }
{\Gamma \vdash \text{let} \, x : \sigma = e; e' : \tau} \\
\\
\frac
{}
{\Gamma \vdash \text{extern} \, \text{sym} \, \sigma \to \tau : \text{void} \star} \\
\\
\frac
{\Gamma \vdash e : \text{void} \star \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash e(e' : \tau) : \sigma} \\
\\
\frac
{\Gamma \vdash e : \sigma \quad \Gamma \vdash e' : \sigma'}
{\Gamma \vdash (e, e') : (\sigma, \sigma') } \\
\\
\frac
{\Gamma \vdash e : (\sigma, \sigma') \quad \Gamma, x : \sigma, x' : \sigma' \vdash e' : \tau}
{\Gamma \vdash \text{let} (x: \sigma, x' : \sigma') = e; e' : \tau} \\
\\
\frac
{\Gamma \vdash e : \text{void} \star}
{\Gamma \vdash \star e : \sigma} \\
\\
\frac
{}
{\Gamma \vdash n : \sigma} \\
\\
\frac
{\Gamma \vdash e : \text{word} \, s \quad \Gamma \vdash e' : \text{word} \, s }
{\Gamma \vdash e +^z e' : \text{word} \, s}
\end{gather*}

\end{document}
