# useful builtins
inline curry = ~f => ~a => ~b => f(a,b);
inline uncurry = ~f => (a,b) => f(a)(b);

inline to macro1 = ~f => f`;
inline to macro2 = ~f => ~a => ~b =>  f`(a,b);
inline to macro3 = ~f => ~a => ~b => ~c =>  f`(a,b,c);


# io for tests
inline assert impl = extern "assert" (& boolean, world &) -> (& (& &), world&);
inline assert = assert impl.to macro2;

inline write impl = extern "write" (& raw character[], world &) -> (& (& &), world &);
inline write = write impl.to macro2;

# builtin functions
inline new impl = extern "aith_create_pointer" <a extends unrestricted> (& a, world &) -> (& raw a*, world &);
~ <a extends unrestricted> a ~> world ~> (& raw a*, world &) ~
inline new = new impl.to macro2;

inline new array impl = extern "aith_new_array" <a extends unrestricted> (& natural, a, world &) -> (& raw a[] , world &);
~ <a extends unrestricted> natural ~> a ~> world ~> (& raw a[] , world &) ~
inline new array = new array impl.to macro3;

inline length impl = extern "aith_array_length" <a> raw a[] -> natural;
inline length = length impl.to macro1;

# desugaring for do notation
~ <a,s> a ~> s ~> (& a, s &) ~
inline desugar pure = ~item => ~os => (item, os);

~ <a,b,s> (s ~> (& a, s &)) ~> (a ~> s ~> (& b, s&)) ~> s ~> (& b, s &) ~
inline desugar bind = ~monad => ~continue => ~os {
	(x, |os|) = monad(os);
	continue(x)(os)
};

~ <a,s> boolean ~> (s ~> (& a, s &)) ~> (s ~> (& a, s &)) ~> s ~> (& a, s &) ~
inline desugar choose = ~choice => ~left => ~right => ~os {
	if choice {
		left(os)
	} else {
		right(os)
	}
};

# desugar for array and string literals
~ <a> a ~> world ~> (& a, world &) ~
inline desugar effect = desugar pure;

# desugar for array and pointer operations
inline desugar index address impl = extern "aith_array_address_of" <a> (& raw a[], natural &) -> raw a*;
inline desugar index address = desugar index address impl.to macro2;

inline desugar assign impl = extern "aith_pointer_assign" <a> (& raw a*, a, world &) -> (& (& &), world &);
inline desugar assign = desugar assign impl.to macro3;

inline desugar index impl = extern "aith_index_array" <a> (& raw a[], natural, world &) -> (& a, world &);
inline desugar index = desugar index impl.to macro3;

inline desugar slice impl = extern "aith_array_slice" <a> (& raw a[], natural, natural &) -> raw a[];
inline desugar slice = desugar slice impl.to macro3;

inline desugar derefence impl = extern "aith_derefence_pointer" <a> (& raw a*, world &) -> (& a, world &);
inline desugar derefence = desugar derefence impl.to macro2;

inline integer32 less = extern "aith_number_integer32_less" (& integer32, integer32 &) -> boolean;
inline integer32 greater = extern "aith_number_integer32_greater" (& integer32, integer32 &) -> boolean;
inline integer32 less equal = extern "aith_number_integer32_less_equal" (& integer32, integer32 &) -> boolean;
inline integer32 greater equal = extern "aith_number_integer32_greater_equal" (& integer32, integer32 &) -> boolean;
inline integer32 add = extern "aith_number_integer32_add" (& integer32, integer32 &) -> integer32;
inline integer32 subtract = extern "aith_number_integer32_subtract" (& integer32, integer32 &) -> integer32;
inline integer32 multiply = extern "aith_number_integer32_multiply" (& integer32, integer32 &) -> integer32;
inline integer32 divide = extern "aith_number_integer32_divide" (& integer32, integer32 &) -> integer32;
inline integer32 modulus = extern "aith_number_integer32_modulus" (& integer32, integer32 &) -> integer32;
inline integer32 negate = extern "aith_number_integer32_negate" integer32 -> integer32;

inline natural32 less = extern "aith_number_natural32_less" (& natural32, natural32 &) -> boolean;
inline natural32 greater = extern "aith_number_natural32_greater" (& natural32, natural32 &) -> boolean;
inline natural32 less equal = extern "aith_number_natural32_less_equal" (& natural32, natural32 &) -> boolean;
inline natural32 greater equal = extern "aith_number_natural32_greater_equal" (& natural32, natural32 &) -> boolean;
inline natural32 add = extern "aith_number_natural32_add" (& natural32, natural32 &) -> natural32;
inline natural32 subtract = extern "aith_number_natural32_subtract" (& natural32, natural32 &) -> natural32;
inline natural32 multiply = extern "aith_number_natural32_multiply" (& natural32, natural32 &) -> natural32;
inline natural32 divide = extern "aith_number_natural32_divide" (& natural32, natural32 &) -> natural32;
inline natural32 modulus = extern "aith_number_natural32_modulus" (& natural32, natural32 &) -> natural32;
inline natural32 negate = extern "aith_number_natural32_negate" natural32 -> natural32;

inline integer less = extern "aith_number_integer_less" (& integer, integer &) -> boolean;
inline integer greater = extern "aith_number_integer_greater" (& integer, integer &) -> boolean;
inline integer less equal = extern "aith_number_integer_less_equal" (& integer, integer &) -> boolean;
inline integer greater equal = extern "aith_number_integer_greater_equal" (& integer, integer &) -> boolean;
inline integer add = extern "aith_number_integer_add" (& integer, integer &) -> integer;
inline integer subtract = extern "aith_number_integer_subtract" (& integer, integer &) -> integer;
inline integer multiply = extern "aith_number_integer_multiply" (& integer, integer &) -> integer;
inline integer divide = extern "aith_number_integer_divide" (& integer, integer &) -> integer;
inline integer modulus = extern "aith_number_integer_modulus" (& integer, integer &) -> integer;
inline integer negate = extern "aith_number_integer_negate" integer -> integer;

inline natural less = extern "aith_number_natural_less" (& natural, natural &) -> boolean;
inline natural greater = extern "aith_number_natural_greater" (& natural, natural &) -> boolean;
inline natural less equal = extern "aith_number_natural_less_equal" (& natural, natural &) -> boolean;
inline natural greater equal = extern "aith_number_natural_greater_equal" (& natural, natural &) -> boolean;
inline natural add = extern "aith_number_natural_add" (& natural, natural &) -> natural;
inline natural subtract = extern "aith_number_natural_subtract" (& natural, natural &) -> natural;
inline natural multiply = extern "aith_number_natural_multiply" (& natural, natural &) -> natural;
inline natural divide = extern "aith_number_natural_divide" (& natural, natural &) -> natural;
inline natural modulus = extern "aith_number_natural_modulus" (& natural, natural &) -> natural;
inline natural negate = extern "aith_number_natural_negate" natural -> natural;


overload less class { <a> (&a, a&) -> boolean } = instance (integer32) {
	integer32 less
} ||| instance (natural32) {
	natural32 less
} ||| instance (integer) {
	integer less
} ||| instance (natural) {
	natural less
};


overload greater class { <a> (&a, a&) -> boolean } = instance (integer32) {
	integer32 greater
} ||| instance (natural32) {
	natural32 greater
} ||| instance (integer) {
	integer greater
} ||| instance (natural) {
	natural greater
};

overload less equal class { <a> (&a, a&) -> boolean } = instance (integer32) {
	integer32 less equal
} ||| instance (natural32) {
	natural32 less equal
} ||| instance (integer) {
	integer less equal
} ||| instance (natural) {
	natural less equal
};


overload greater equal class { <a> (&a, a&) -> boolean } = instance (integer32) {
	integer32 greater equal
} ||| instance (natural32) {
	natural32 greater equal
} ||| instance (integer) {
	integer greater equal
} ||| instance (natural) {
	natural greater equal
};

overload add class { <a> (& a, a&) -> a } = instance (integer32) {
	integer32 add
} ||| instance (natural32) {
	natural32 add
} ||| instance (integer) {
	integer add
} ||| instance (natural) {
	natural add
};

overload subtract class { <a> (& a, a&) -> a } = instance (integer32) {
	integer32 subtract
} ||| instance (natural32) {
	natural32 subtract
} ||| instance (integer) {
	integer subtract
} ||| instance (natural) {
	natural subtract
};

overload multiply class { <a> (& a, a&) -> a } = instance (integer32) {
	integer32 multiply
} ||| instance (natural32) {
	natural32 multiply
} ||| instance (integer) {
	integer multiply
} ||| instance (natural) {
	natural multiply
};

overload divide class { <a> (& a, a&) -> a } = instance (integer32) {
	integer32 divide
} ||| instance (natural32) {
	natural32 divide
} ||| instance (integer) {
	integer divide
} ||| instance (natural) {
	natural divide
};

overload modulus class { <a> (& a, a&) -> a } = instance (integer32) {
	integer32 modulus
} ||| instance (natural32) {
	natural32 modulus
} ||| instance (integer) {
	integer modulus
} ||| instance (natural) {
	natural modulus
};

overload negate class { <a> a -> a } = instance (integer32) {
	integer32 negate
} ||| instance (natural32) {
	natural32 negate
} ||| instance (integer) {
	integer negate
} ||| instance (natural) {
	natural negate
};


# math desugaring
inline desugar less = require less class.to macro2;
inline desugar greater = require greater class.to macro2;
inline desugar less equal = require less equal class.to macro2;
inline desugar greater equal = require greater equal class.to macro2;

inline desugar add = require add class.to macro2;
inline desugar subtract = require subtract class.to macro2;
inline desugar multiply = require multiply class.to macro2;
inline desugar divide = require divide class.to macro2;
inline desugar modulus = require modulus class.to macro2;
inline desugar negate = require negate class.to macro1;

# logic desugaring
inline desugar not impl = extern "aith_not" boolean -> boolean;
inline desugar not = desugar not impl.to macro1;

inline desugar equal = require equal.to macro2;
inline desugar not equal = ~left => ~right => !(left == right);

inline desugar and impl = extern "aith_and" (& boolean , boolean &) -> boolean;
inline desugar and = desugar and impl.to macro2;

inline desugar or impl = extern "aith_or" (& boolean , boolean &) -> boolean;
inline desugar or = desugar or impl.to macro2;

# desugar utils for tuple index and tuple index address
inline desugar fst = (get,forward) => get;
inline desugar snd = (get,forward) => forward;
