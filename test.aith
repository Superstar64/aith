module this;

inline runtimeCall = \f => \x => f (x);

module combinators = {
	inline flip = \f => \x => \y => f !y !x;
	inline compose = \f => \g => \x => f !(g !x);
	
	inline readerPure = \x => \r => x;
	inline readerBind = \m => \f => \r => f !(m !r) !r;
	inline readerMap = \f => \m => readerBind !m !(compose !readerPure !f);
};

module systemf = {
	type natural = <A : type> A -> (A -> A) -> A;

	inline zero<> : natural;
	inline zero = <A : type> \z : A => \inc : A -> A => z;

	inline inc<> : natural -> natural;
	inline inc = \n : natural => <A : type> \z : A => \inc => inc !(n <_> !z !inc);

	inline one<> : natural;
	inline one = inc !zero;

	inline two<> : natural;
	inline two = inc !one;
};

module systemfPoly = {
	inline explicit<> : <A : type> A -> A;
	inline explicit<> = <A : type> \x : A => x;
	
	inline implicit<A : type> : A -> A;
	inline implicit = explicit <_>;

	inline use = implicit !(explicit) <_>;

	inline useArgument = \x : <A :type> A -> A => x <_>;

	inline curry<> : <A : type> <B : type> (A -> B) -> A -> B;
	inline curry<> = <A : type> <B : type> \f : A -> B => f;

	inline useCurry = curry <_> <_> !(implicit);

	inline immediate = (<A : type, B : type> \f : A -> B => \x => f !x) <_>;
};

module default = {
	add(x,y) {
		x + y
	}

	ambigous(x) {
		inline y = 1;
		x
	}
};

module unit = {
	idUnit () {
		()
	}
};

module boolean = {
	inline yes = true;

	branch(b) {
		if b {
			1
		} else {
			2
		}
	}

	complex(b) {
		if {if (b) { true } else {false} } {
			1
		} else {
			if yes {
				2
			} else {
				4
			}
		}
	}

	not(b) {
		!b
	}

	inBounds(x1, x2, x3) {
		x1 <= x2 & x2 < x3
	}
};

module pair = {
	fst(x, y) {
		x
	}

	snd(x, y) {
		y
	}
	
	pattern (pair) {
		(fst(pair), snd(pair))
	}
};

module ptr = {
	derefTriple(x) {
		***x
	}

	deref <A : region, T : pretype<pointer, true>>(x :: T* @ A) :: T in A;
	deref (x) {
		*x
	}

	write<A:region>(x :: int* @ A) :: () in A;
	write<A:region>(x :: int* @ A) {
		*x = (1 :: int)
	}

	writeTriple(x) {
		***x = (1) 
	}

	swap(x,y) {
		let xp = (*x);
		*x = (*y);
		*y = (xp);
		()
	}
};


module number = {
	type point = (int, int, int);

	dotProduct<>(x :: point, y :: point) :: int in false;
	dotProduct((x1,y1,z1), (x2, y2, z2)) {
		(x1 * x2 + y1 * y2 + z1 * z2)
	}
  
	mid <>(x :: uint, y:: uint) :: uint in false;
	mid <>(x,y) {
		(x + y) / 2
	}

	lessEqual(x,y) {
		x <= y
	}

	factorial<>(x :: ulong) :: ulong in false; 
	factorial<>(x) {
		if (x == 0) {
			1
		} else {
			x * factorial (x - 1)  
		}
	}
};

module fptr = {
	call(f) {
		f (1)
	}

	callUnit <>(f :: function(uint) => () uses false) :: () in false;
	callUnit <>(f) {
		f (2)
	}
};

module recurse = {
	explode<L : multiplicity, A:pretype<pointer, L>>() :: A in false;
	explode<L : multiplicity, A:pretype<pointer, L>>() {
		explode ()
	}
};

module world = {
	inline lenient = {
		if false {
			* {
				switch() {
					
				}
			}
		} else {
			()
		}
	};


	inline putchar<> : function(int) => int uses io in false;
	inline putchar<> = extern "putchar";

	putPtr<A:region>(ptr :: int* @ A) :: int in A | io;
	putPtr(ptr) {
		putchar (*ptr)
	}

	inline count = /systemf/two;
	putHashes() {
		count <_> !(lenient) !\s { 
			let n = putchar (35);
			s
		}
	}
};

module arrays = {
	inline get = \x => \i {
		* &* &x[i]
	};

	inline set = \x => \i => \a {
		* &* &x[i] = (a)
	};

	swap(a, b, i) {
		let tmp = get !a !i;
		set !a !i !(get !b !i);
		set !b !i !tmp;
		()
	}

	memcpyPtr(dst, src, i) {
		loop (let (dst, src, i) = (dst, src, i)) {
			if(i != 0) {
				* &* dst = (* &* src);
				continue (&dst[1], &src[1], i - 1)
			} else {
				break ()
			}
		}
	}
};

module sort = {

	inline get = /arrays/get;

	inline set = /arrays/set;

	insert(array, index) {
		loop (let (array, index) = (array,index)) {
			if (index > 0 & get !array !index < get !array !(index - 1) ) {
				let tmp = get !array !index;
				set !array !index !(get !array !(index - 1));
				set !array !(index - 1) !tmp;
				continue (array, index - 1)
			} else {
				break ()
			}
		}
	}

	sort <R : region> (array :: int[] @ R, index :: unsigned integer(native)) :: () in R;
	sort <R : region>(array, length) {
		if (length > 1) {
			sort(array, length - 1);
			insert(array, length - 1)
		} else {
			()
		}
	}
};

module borrowed = {
	increment<>(p :: unique int*) :: unique int* in false;
	increment (p :: unique int*) {
		let ((), p) = {
			borrow p as <A : region>(x :: int* @ A) {
				*x = (*x + 1)
			} uses false
		};
		p
	}
};

module partial = {
	inline auto = \x => x;
	
	inline semi<A : type> = \x : A => x;

	inline scoped<A : type> : A -> A;
	inline scoped = \x : A => x;

	inline manual<A : type> : A -> A;
	inline manual<A : type> = \x => x;
};

module import = {
	inline id = \x => x;
	module b = {
		inline const = \y => /import/id;
	};
};

module levity = {
	idPolyPair<A : pretype<struct(pointer, 32bit word), false>>(x :: A) {
		x
	}

	idPolyUnion<A : pretype<union(pointer, 32bit word), false>>(x :: A) {
		x
	}

	useId(ptr) {
		idPolyPair(ptr, 0)
	}
};

module sum = {
	triangular(start, end) {
		loop (let (i, total) = (start, 0)) {
			if (i <= end) {
				continue (i + 1, total + i)
			} else {
				break (total)
			}
		}
	}
};

module newtype = {
	wrapper num : pretype<32bit word, true>;
	wrapper num = int;

	makeNum() {
		wrap 1 :: num
	}


	wrapper linked : pretype<pointer, true>;
	wrapper linked = linked2* @ io;

	type linked2 = linked;

	read (x) {
		*unwrap (x :: linked)
	}
};

module case = {
	explode() {
		switch () {}
	}

	boolPair (a,b) {
		switch (a,b) {
			(true, true) => 1;
			(true, false) => 2;
			(false, true) => 3;
			(false, false) => 4;
		}
	}
};

module use = {
	use<
		B:region,
		C:region
	>(
		x :: int* @ B,
		y :: int* @ C
	) :: int in B | C;
	use(x, y) {
		*x + *y
	}
};

module redundant = {
	nop(x) {
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x);
		*x = (*x)
	}
};