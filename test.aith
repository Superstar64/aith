module:::

inline runtimeCall = \f => \x => f (x);

module combinators = {
	inline flip = \f => \x => \y => f `y `x;
	inline compose = \f => \g => \x => f `(g `x);
	
	inline readerPure = \x => \![r] => x;
	inline readerBind = \m => \f => \![r] => f `(m `![r]) `![r];
	inline readerMap = \f => \m => readerBind `m `(compose `readerPure `f);
};

module systemf = {
	inline ignored <B : *> : \/A : * => B -> B;
	inline ignored <B> = /\A : * => \(x : B) => x;

	inline idSysF = /\A : * => \(x : A) => x;

	inline runIdSysF = \f {
		(f : \/A => A -> A)`<_>
	};

	inline id = runIdSysF `idSysF;

	inline constSysF = /\A : * => /\B : * => \![x : A] => \![y : B] => x;

	inline const <A:*, B:*> : ![A] -> ![B] -> A;
	inline const <A,B> = ((constSysF : \/A => \/B => ![A] -> ![B] -> A)`<_> : \/ B => ![A] -> ![B] -> A)`<_>;

};

module varSub = {
	inline sub<A : *, B : * >= A, C:*> : ![A] -> ![B] -> C -> C;
	inline sub<A,B,C> = \![a : A] => \![b : B] => \x => x;


	inline cycle = \![a] => \![b] => \![c] {
		sub `![a] `![b] `(
			sub `![b] `![c] `(
				sub `![c] `![a] `(
					\x => x
				)
			)
		)
	};

	inline rigid<A : * >= (\/B : * => B -> B), C : *> : ![A] -> C -> C;
	inline rigid<A, C> = \![a] => sub `![/\D : * => \y : D => y] `![a];
};

module default = {
	add = function(x,y) {
		x + y
	};

	ambigous = function(x) {
		inline ![y] = ![1];
		x
	};
};

module unit = {
	idUnit = function () {
		()
	};
};

module boolean = {
	inline yes = true;

	branch = function(b) {
		if b {
			1
		} else {
			2
		}
	};

	complex = function(b) {
		if (if (b) { true } else {false} ) {
			1
		} else {
			if yes {
				2
			} else {
				4
			}
		}
	};

	not = function(b) {
		~b
	};

	inBounds = function(x1, x2, x3) {
		x1 <= x2 & x2 < x3
	};
};

module pair = {
	inline fstSysF = /\A : +[pointer] => /\B : +[pointer] if copy => function(x :: A, y :: B) => x;
  
	fst <A : +[pointer], B : +[pointer] if copy, R : region> :  function (A, B) => A uses R;
	fst <A, B, R> = ((fstSysF : \/A => \/B if copy => function (A,B) => A uses R)`<_> : \/B if copy => function(A,B) => A uses R)`<_>;
	
	snd <A : +[pointer] if copy, B : +[pointer], R : region> : function (A, B) => B uses R;
	snd <A,B,R> = function(x, y) => y;
	
	pattern = function (pair) {
		(fst (pair), snd (pair))
	};
};

module ptr = {
	derefTriple = function(x) {
		***x
	};

	deref <RA : region, RB : region >= RA, T : +[pointer] if copy, L : capacity> : function (T[L] @ RA) => T uses RB;
	deref <RA : region, RB : region >= RA, T : +[pointer] if copy, L : capacity> = function (x) {
		*x
	};

	write<A:region, B:region >= A, L : capacity> : function(int[L] @ A) => () uses B;
	write<A:region, B:region >= A, L : capacity> = function(x :: int[L] @ A) {
		*x = (1 :: int)
	};

	writeTriple = function(x) {
		***x = 1 
	};

	swap = function(x,y) {
		let xp = *x;
		*x = (*y);
		*y = xp;
		()
	};
};

module integer = {
	dotProduct = function(vector1P, vector2P) {
		let (x1,y1,z1) = *vector1P;
		let (x2,y2,z2) = *vector2P;
		(x1 * x2 + y1 * y2 + z1 * z2)
	};
  
	mid <R : region> : function(uint, uint) => uint uses R;
	mid <R : region> = function(x,y) {
		(x + y) / 2
	};

	inline divGen = function(x,y) {
		(x + y - 1) / y
	};

	div = divGen;

	lessEqual = function(x,y) {
		x <= y
	};

	factorial<R : region> : function(ulong) => ulong uses R; 
	factorial<R : region> = function(x) {
		if (x == 0) {
			1
		} else {
			x * factorial (x - 1)  
		}
	};
};

module fptr = {
	call = function(f) {
		f (1)
	};

	callUnit <R : region> : function(function*(uint) => () uses R) => () uses R;
	callUnit <R : region> = function(f) {
		f (2)
	};
};

module recurse = {
	explode<R:region, A:+[pointer]> : function() => A uses R;
	explode<R:region, A:+[pointer]> = function() {
		explode ()
	};
};

module world = {
	inline putchar<A:region> : function*(int) => int uses io in A;
	inline putchar<A> = extern "putchar";

	putPtr<A:region >= io, L : capacity> : function(int[L] @ A) => int uses A;
	putPtr<A,L> = function(ptr) {
		putchar (*ptr)
	};
};

module arrays = {
	inline get = \x => \i {
		*&x[i]
	};

	inline set = \x => \i => \a {
		*&x[i] = a
	};

	swap = function(a, b, i) {
		let tmp = get `a `i;
		set `a `i `(get `b `i);
		set `b `i `tmp;
		()
	};

	memcpyPtr <A : +[pointer] if copy, R : region> : function(A[*] @ R, A[*] @ R, native) => () uses R; 
	memcpyPtr <A : +[pointer] if copy, R : region> = function(dst, src, i) {
		if(i != 0) {
			*dst = (*src);
			memcpyPtr (&dst[1], &src[1], i - 1)
		} else {
			()
		}
	};
};

module sort = {
	insert<R : region> : function(int[*] @ R, native) => () uses R;
	insert<R : region> = function(array, index) {
		if (index > 0 & *&array[index] < *&array[index - 1]) {
			let tmp = *&array[index];
			*&array[index] = (*&array[index - 1]);
			*&array[index - 1] = tmp;
			insert(array, index - 1)
		} else {
			()
		}
	};

	sort <R : region> : function(int[*] @ R, native) => () uses R;
	sort <R : region> = function(array, length) {
		if (length > 1) {
			sort(array, length - 1);
			insert(array, length - 1)
		} else {
			()
		}
	};
};