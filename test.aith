module this;

inline runtimeCall = \f => \x => f (x);

module combinators = {
	inline flip = \f => \x => \y => f !y !x;
	inline compose = \f => \g => \x => f !(g !x);
	
	inline readerPure = \x => \r => x;
	inline readerBind = \m => \f => \r => f !(m !r) !r;
	inline readerMap = \f => \m => readerBind !m !(compose !readerPure !f);
};

module systemf = {
	type natural = <A : type> A -> (A -> A) -> A;

	inline zero<> : natural;
	inline zero = <A : type> \z : A => \inc : A -> A => z;

	inline inc<> : natural -> natural;
	inline inc = \n : natural => <A : type> \z : A => \inc => inc !(n <_> !z !inc);

	inline one<> : natural;
	inline one = inc !zero;

	inline two<> : natural;
	inline two = inc !one;
};

module systemfPoly = {
	inline explicit<> : <A : type> A -> A;
	inline explicit<> = <A : type> \x : A => x;
	
	inline implicit<A : type> : A -> A;
	inline implicit = explicit <_>;

	inline use = implicit !(explicit) <_>;

	inline useArgument = \x : <A :type> A -> A => x <_>;

	inline curry<> : <A : type> <B : type> (A -> B) -> A -> B;
	inline curry<> = <A : type> <B : type> \f : A -> B => f;

	inline useCurry = curry <_> <_> !(implicit);
};

module varSub = {
	inline sub<R : pretype<pointer, unrestricted>, A : region, B : region >= A, C:type>
    : R in A -> R in B -> C -[linear]> C;
	inline sub = \a => \b => \x => x;


	inline cycle = \a => \b => \c {
		sub !a !b !(
			sub !b !c !(
				sub !c !a !(
					\x => x
				)
			)
		)
	};
};

module default = {
	add(x,y) {
		x + y
	}

	ambigous(x) {
		inline y = 1;
		x
	}
};

module unit = {
	idUnit () {
		()
	}
};

module boolean = {
	inline yes = true;

	branch(b) {
		if b {
			1
		} else {
			2
		}
	}

	complex(b) {
		if {if (b) { true } else {false} } {
			1
		} else {
			if yes {
				2
			} else {
				4
			}
		}
	}

	not(b) {
		!b
	}

	inBounds(x1, x2, x3) {
		x1 <= x2 & x2 < x3
	}
};

module pair = {
	fst(x, y) {
		x
	}

	snd(x, y) {
		y
	}
	
	pattern (pair) {
		(fst(pair), snd(pair))
	}
};

module ptr = {
	derefTriple(x) {
		***x
	}

	deref <RA : region, RB : region >= RA, T : pretype<pointer, unrestricted>>(x :: T* @ RA) :: T in RB;
	deref <RA : region, RB : region >= RA, T : pretype<pointer, unrestricted>> (x) {
		*x
	}

	write<A:region, B:region >= A>(x :: int* @ A) :: () in B;
	write<A:region, B:region >= A>(x :: int* @ A) {
		*x = (1 :: int)
	}

	writeTriple(x) {
		***x = 1 
	}

	swap(x,y) {
		let xp = *x;
		*x = (*y);
		*y = xp;
		()
	}
};


module number = {
	type point = (int, int, int);

	dotProduct <R : region>(x :: point, y :: point) :: int in R;
	dotProduct((x1,y1,z1), (x2, y2, z2)) {
		(x1 * x2 + y1 * y2 + z1 * z2)
	}
  
	mid <R : region>(x :: uint, y:: uint) :: uint in R;
	mid <R : region>(x,y) {
		(x + y) / 2
	}

	lessEqual(x,y) {
		x <= y
	}

	factorial<R : region>(x :: ulong) :: ulong in R; 
	factorial<R : region>(x) {
		if (x == 0) {
			1
		} else {
			x * factorial (x - 1)  
		}
	}
};

module fptr = {
	call(f) {
		f (1)
	}

	callUnit <R : region>(f :: function(uint) => () uses R) :: () in R;
	callUnit <R : region>(f) {
		f (2)
	}
};

module recurse = {
	explode<L : multiplicity, R:region, A:pretype<pointer, L>>() :: A in R;
	explode<L : multiplicity, R:region, A:pretype<pointer, L>>() {
		explode ()
	}
};

module world = {
	inline putchar<A:region> : function(int) => int uses io in A;
	inline putchar<A:region> = extern "putchar";

	putPtr<A:region >= io>(ptr :: int* @ A) :: int in A;
	putPtr(ptr) {
		putchar (*ptr)
	}
};

module arrays = {
	inline get = \x => \i {
		* &* &x[i]
	};

	inline set = \x => \i => \a {
		* &* &x[i] = a
	};

	swap(a, b, i) {
		let tmp = get !a !i;
		set !a !i !(get !b !i);
		set !b !i !tmp;
		()
	}

	memcpyPtr(dst, src, i) {
		loop (let (dst, src, i) = (dst, src, i)) {
			if(i != 0) {
				* &* dst = (* &* src);
				continue (&dst[1], &src[1], i - 1)
			} else {
				break ()
			}
		}
	}
};

module sort = {

	inline get = /arrays/get;

	inline set = /arrays/set;

	insert<R : region>(array :: int[] @ R, index :: unsigned integer(native)) :: () in R;
	insert<R : region>(array, index) {
		loop (let (array, index) = (array,index)) {
			if (index > 0 & get !array !index < get !array !(index - 1) ) {
				let tmp = get !array !index;
				set !array !index !(get !array !(index - 1));
				set !array !(index - 1) !tmp;
				continue (array, index - 1)
			} else {
				break ()
			}
		}
	}

	sort <R : region> (array :: int[] @ R, index :: unsigned integer(native)) :: () in R;
	sort <R : region>(array, length) {
		if (length > 1) {
			sort(array, length - 1);
			insert(array, length - 1)
		} else {
			()
		}
	}
};

module borrowed = {
	increment <R : region>(p :: unique int*) :: unique int* in R;
	increment <R : region>(p :: unique int*) {
		let ((), p) = { borrow p as <A : region >= R>(x :: int* @ A) {
			*x = (*x + 1)
		}};
		p
	}
};

module partial = {
	inline auto = \x => x;
	
	inline semi<A : type> = \x : A => x;

	inline scoped<A : type> : A -> A;
	inline scoped = \x : A => x;

	inline manual<A : type> : A -> A;
	inline manual<A : type> = \x => x;
};

module import = {
	inline id = \x => x;
	module b = {
		inline const = \y => /import/id;
	};
};

module levity = {
	idPolyPair<A : pretype<struct(pointer, 32bit word) ,linear>>(x :: A) {
		x
	}

	idPolyUnion<A : pretype<union(pointer, 32bit word) ,linear>>(x :: A) {
		x
	}

	useId(ptr) {
		idPolyPair(ptr, 0)
	}
};

module sum = {
	triangular(start, end) {
		loop (let (i, total) = (start, 0)) {
			if (i <= end) {
				continue (i + 1, total + i)
			} else {
				break (total)
			}
		}
	}
};

module newtype = {
	wrapper num : pretype<32bit word, unrestricted>;
	wrapper num = int;

	makeNum() {
		wrap 1 :: num
	}


	wrapper linked : pretype<pointer, unrestricted>;
	wrapper linked = linked2* @ io;

	type linked2 = linked;

	read (x) {
		*unwrap (x :: linked)
	}
};

module universes = {
	inline abstract<U : kind<subtypable, transparent, 1u>> = <T : U> \x : int in io {
		x
	};

	inline use = (abstract : <T : region> int in io -> int in io) <_>;
};