module:

inline runtimeCall = `\f => `\x => f $ x;

module combinators = {
	inline flip = `\f => `\x => `\y => f `y `x;
	inline compose = `\f => `\g => `\x => f `(g `x);
	
	inline readerPure = `\x => `\![r] => x;
	inline readerBind = `\m => `\f => `\![r] => f `(m `![r]) `![r];
	inline readerMap = `\f => `\m => readerBind `m `(compose `readerPure `f);
};


module run = {
	import call = /test/runtimeCall;
	
	
	symbol dotProduct = \(vector1P, vector2P) {
		let (x1,y1,(z1 : {{signed}} int)) = *vector1P;
		let (x2,y2,z2) = *vector2P;
		(x1 * x2 + y1 * y2 + z1 * z2)
	};
  
	inline fstSysF = /\A : +[#pointer#] => /\B : +[#pointer#] + copy => \((x : A), (y : B)) => x;
  
  
	symbol _ :: <A : +[#pointer#], B : +[#pointer#] + copy, R : region> (A, B) -> R A;
	symbol fst = fstSysF[[\/A => \/B + copy => (A,B) -> R A]]<_>[[\/B + copy => (A,B) -> R A]]<_>;
	
	symbol _ :: <A : +[#pointer#] + copy, B : +[#pointer#], R : region> (A, B) -> R B;
	symbol snd = \(x, y) => y;
	
	symbol pattern = \pair {
		(fst $ pair), (snd $ pair)
	};
  
	symbol _ :: <R : region> {{unsigned}} int, {{unsigned}} int -> R {{unsigned}} int; 
	symbol mid = \(x,y) {
		(x + y) / 2
	};
  
	symbol _ :: <R : region> {{unsigned}} int, {{unsigned}} int -> R {{unsigned}} int;
	symbol div = \(x,y) {
		(x + y - 1) / y
	};
};


module systemf = {

	inline _ :: <B : *> \/A => B -`> B;
	inline ignored = /\A : * => `\(x : B) => x;

	inline idSysF = /\A => `\(x : A) => x;

	inline runIdSysF = `\f {
		f[[\/A => A -`> A]]<_>
	};

	inline id = runIdSysF `idSysF;

	inline constSysF = /\A => /\B => `\![x : A] => `\![y : B] => x;

	inline _ :: <A:*, B:*> ![A] -`> ![B] -`> A;
	inline const = constSysF[[\/A => \/B => ![A] -`> ![B] -`> A]]<_>[[\/ B => ![A] -`> ![B] -`> A]]<_>;

};
