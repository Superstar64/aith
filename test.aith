module:

inline runtimeCall = `\f => `\x => f $ x;

module combinators = {
	inline flip = `\f => `\x => `\y => f `y `x;
	inline compose = `\f => `\g => `\x => f `(g `x);
	
	inline readerPure = `\x => `\![r] => x;
	inline readerBind = `\m => `\f => `\![r] => f `(m `![r]) `![r];
	inline readerMap = `\f => `\m => readerBind `m `(compose `readerPure `f);
};


module run = {
	import call = /test/runtimeCall;
	
	deref <RA : region, RB : region >= RA, T : +[#pointer#] + copy > :: T* @ RA -> RB T;
	deref <RA, RB, T + copy> = \x {
		*x
	};

	
	dotProduct = \(vector1P, vector2P) {
		let (x1,y1,(z1 : #signed int)) = *vector1P;
		let (x2,y2,z2) = *vector2P;
		(x1 * x2 + y1 * y2 + z1 * z2)
	};
  
	inline fstSysF = /\A : +[#pointer#] => /\B : +[#pointer#] + copy => \((x : A), (y : B)) => x;
  
  
	fst <A : +[#pointer#], B : +[#pointer#] + copy, R : region> ::  (A, B) -> R A;
	fst <A, B, R> = fstSysF[[\/A => \/B + copy => (A,B) -> R A]]<_>[[\/B + copy => (A,B) -> R A]]<_>;
	
	snd <A : +[#pointer#] + copy, B : +[#pointer#], R : region> :: (A, B) -> R B;
	snd <A,B,R> = \(x, y) => y;
	
	pattern = \pair {
		(fst $ pair), (snd $ pair)
	};
  
	mid <R : region> :: #unsigned int, #unsigned int -> R #unsigned int; 
	mid <R> = \(x,y) {
		(x + y) / 2
	};
  
	div <R : region> :: #unsigned int, #unsigned int -> R #unsigned int;
	div <R> = \(x,y) {
		(x + y - 1) / y
	};
};


module systemf = {

	inline ignored <B : *> :: \/A : * => B -`> B;
	inline ignored <B> = /\A : * => `\(x : B) => x;

	inline idSysF = /\A : * => `\(x : A) => x;

	inline runIdSysF = `\f {
		f[[\/A => A -`> A]]<_>
	};

	inline id = runIdSysF `idSysF;

	inline constSysF = /\A : * => /\B : * => `\![x : A] => `\![y : B] => x;

	inline const <A:*, B:*> :: ![A] -`> ![B] -`> A;
	inline const <A,B> = constSysF[[\/A => \/B => ![A] -`> ![B] -`> A]]<_>[[\/ B => ![A] -`> ![B] -`> A]]<_>;

};