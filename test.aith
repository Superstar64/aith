module ::

inline runtimeCall = \f => \x => f (x);

module combinators = {
	inline flip = \f => \x => \y => f `y `x;
	inline compose = \f => \g => \x => f `(g `x);
	
	inline readerPure = \x => \![r] => x;
	inline readerBind = \m => \f => \![r] => f `(m `![r]) `![r];
	inline readerMap = \f => \m => readerBind `m `(compose `readerPure `f);
};

module systemf = {
	inline ignored <B : type> : <A : type> B -> B;
	inline ignored <B : type> = <A : type> \(x : B) => x;

	inline idSysF = <A : type> \x : A => x;

	inline runIdSysF = \f {
		|< f : <A : type> A -> A >|
	};

	inline id = runIdSysF `idSysF;

	inline constSysF = <A : type, B : type> \![x : A] => \![y : B] => x;

	inline const <A : type, B : type> : ![A] -> ![B] -> A;
	inline const <A : type, B : type> = |< constSysF : <A : type, B : type> ![A] -> ![B] -> A >|;

};

module varSub = {
	inline sub<R : pretype<pointer>, A : region, B : region >= A, C:type> : ![R in A] -> ![R in B] -> C -> C;
	inline sub = \![a] => \![b] => \x => x;


	inline cycle = \![a] => \![b] => \![c] {
		sub `![a] `![b] `(
			sub `![b] `![c] `(
				sub `![c] `![a] `(
					\x => x
				)
			)
		)
	};
};

module default = {
	add = function(x,y) {
		x + y
	};

	ambigous = function(x) {
		inline ![y] = ![1];
		x
	};
};

module unit = {
	idUnit = function () {
		()
	};
};

module boolean = {
	inline yes = true;

	branch = function(b) {
		if b {
			1
		} else {
			2
		}
	};

	complex = function(b) {
		if (if (b) { true } else {false} ) {
			1
		} else {
			if yes {
				2
			} else {
				4
			}
		}
	};

	not = function(b) {
		~b
	};

	inBounds = function(x1, x2, x3) {
		x1 <= x2 & x2 < x3
	};
};

module pair = {
	inline fstSysF = <A : pretype<pointer>, B : pretype<pointer> if copy> function(x :: A, y :: B) => x;
  
	fst <A : pretype<pointer>, B : pretype<pointer> if copy, R : region> :  function (A, B) => A uses R;
	fst = |< fstSysF : <A : pretype<pointer>, B : pretype<pointer> if copy> function (A,B) => A uses R >|;
	
	snd <A : pretype<pointer> if copy, B : pretype<pointer>, R : region> : function (A, B) => B uses R;
	snd = function(x, y) => y;
	
	pattern = function (pair) {
		(fst (pair), snd (pair))
	};
};

module ptr = {
	derefTriple = function(x) {
		***x
	};

	deref <RA : region, RB : region >= RA, T : pretype<pointer> if copy, L : capacity> : function (T[L] @ RA) => T uses RB;
	deref <RA : region, RB : region >= RA, T : pretype<pointer> if copy, L : capacity> = function (x) {
		*x
	};

	write<A:region, B:region >= A, L : capacity> : function(int[L] @ A) => () uses B;
	write<A:region, B:region >= A, L : capacity> = function(x :: int[L] @ A) {
		*x = (1 :: int)
	};

	writeTriple = function(x) {
		***x = 1 
	};

	swap = function(x,y) {
		let xp = *x;
		*x = (*y);
		*y = xp;
		()
	};
};

module number = {
	dotProduct = function(vector1P, vector2P) {
		let (x1,y1,z1) = *vector1P;
		let (x2,y2,z2) = *vector2P;
		(x1 * x2 + y1 * y2 + z1 * z2)
	};
  
	mid <R : region> : function(uint, uint) => uint uses R;
	mid <R : region> = function(x,y) {
		(x + y) / 2
	};

	inline divGen = function(x,y) {
		(x + y - 1) / y
	};

	div = divGen;

	lessEqual = function(x,y) {
		x <= y
	};

	factorial<R : region> : function(ulong) => ulong uses R; 
	factorial<R : region> = function(x) {
		if (x == 0) {
			1
		} else {
			x * factorial (x - 1)  
		}
	};
};

module fptr = {
	call = function(f) {
		f (1)
	};

	callUnit <R : region> : function(function*(uint) => () uses R) => () uses R;
	callUnit <R : region> = function(f) {
		f (2)
	};
};

module recurse = {
	explode<R:region, A:pretype<pointer>> : function() => A uses R;
	explode<R:region, A:pretype<pointer>> = function() {
		explode ()
	};
};

module world = {
	inline putchar<A:region> : function*(int) => int uses io in A;
	inline putchar<A:region> = extern "putchar";

	putPtr<A:region >= io, L : capacity> : function(int[L] @ A) => int uses A;
	putPtr = function(ptr) {
		putchar (*ptr)
	};
};

module arrays = {
	inline get = \x => \i {
		*&x[i]
	};

	inline set = \x => \i => \a {
		*&x[i] = a
	};

	swap = function(a, b, i) {
		let tmp = get `a `i;
		set `a `i `(get `b `i);
		set `b `i `tmp;
		()
	};

	memcpyPtr <A : pretype<pointer> if copy, R : region> : function(A[:] @ R, A[:] @ R, unsigned integer(native)) => () uses R; 
	memcpyPtr <A : pretype<pointer> if copy, R : region> = function(dst, src, i) {
		if(i != 0) {
			*dst = (*src);
			memcpyPtr (&dst[1], &src[1], i - 1)
		} else {
			()
		}
	};
};

module sort = {
	insert<R : region> : function(int[:] @ R, unsigned integer(native)) => () uses R;
	insert<R : region> = function(array, index) {
		if (index > 0 & *&array[index] < *&array[index - 1]) {
			let tmp = *&array[index];
			*&array[index] = (*&array[index - 1]);
			*&array[index - 1] = tmp;
			insert(array, index - 1)
		} else {
			()
		}
	};

	sort <R : region> : function(int[:] @ R, unsigned integer(native)) => () uses R;
	sort <R : region> = function(array, length) {
		if (length > 1) {
			sort(array, length - 1);
			insert(array, length - 1)
		} else {
			()
		}
	};
};

module borrowed = {
	increment <R : region> : function(unique int[:]) => (unique int[:]) uses R;
	increment <R : region> = function(p :: unique int[:]) {
		let ((), p) = borrow p as <A : region >= R>(x :: int[:] @ A) {
			*x = (*x + 1)
		};
		p
	};
};

module partial = {
	inline auto = \x => x;
	
	inline semi<A : type> = \x : A => x;

	inline scoped<A : type> : A -> A;
	inline scoped = \x : A => x;

	inline manual<A : type> : A -> A;
	inline manual<A : type> = \x => x;
};

module import = {
	inline id = \x => x;
	module b = {
		inline const = \![y] => /import/id;
	};
};