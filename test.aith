module:

inline runtimeCall = `\f => `\x => f $ x;

module combinators = {
	inline flip = `\f => `\x => `\y => f `y `x;
	inline compose = `\f => `\g => `\x => f `(g `x);
	
	inline readerPure = `\x => `\![r] => x;
	inline readerBind = `\m => `\f => `\![r] => f `(m `![r]) `![r];
	inline readerMap = `\f => `\m => readerBind `m `(compose `readerPure `f);
};

import compose = /test/combinators/compose;

module runtime = {
	import call = /test/runtimeCall;
	
	symbol _ :: <A : *[_data @ _real _pointer]> A -> A;
	symbol idPtr = \x => x;
	
	symbol useIdPtr = \x => call `idPtr `x;
	
	symbol _ :: <A : *[_data @ _real _pointer], B : *[_data @ _real _pointer]> _copy B -^> (A, B) -> A;
	symbol fst = ^\proof => \(x, !(proof)[y]) => x;
	
	symbol _ :: <A : *[_data @ _real _pointer], B : *[_data @ _real _pointer]> _copy A -^> (A, B) -> B;
	symbol snd = ^\proof => \(!(proof)[x], y) => y;
	
  
	symbol readBoth = ^\proof => \(p1, p2) {
		_do x1 = _read proof p1;
		_do x2 = _read proof p2;
		_pure (call `idPtr `x1, call `idPtr `x2)
	};
	
	inline copyFunction = _copyFunction;
	
	symbol _ :: <A: *[_data @ _real _pointer]> (A -> A) -> (A -> A), (A -> A);
	symbol cloneFP = \!(copyFunction)[x] {
		(x, x)
	};

  module integers = {
    inline two = 1 + 1;

    symbol _ :: {{_unsigned}} _int -> {{_unsigned}} _int;
    symbol doubleU = \x => x * two;

    symbol _ :: {{_signed}} _int -> {{_signed}} _int;
    symbol doubleI = \x => x * two;
  };
  
  symbol _ :: <R : _region> _reference R ({{_unsigned}} _int, {{_unsigned}} _int) -> _state R {{_unsigned}} _int; 
  symbol squareSum = \p {
    _do (!(_copyNumber)[x],!(_copyNumber)[y]) = _read (_copyPair _copyNumber _copyNumber) p;
    _pure (x * x + y * y) 
  };
  
};


module systemf = {
  inline idSysF = /\A ### (A -`> A) => `\x => x;
  inline runIdSysF = `\f {
    f[[\/A => A -`> A]]<_>
  };
  
  inline id = runIdSysF `idSysF;

  inline _ :: <'X:_stage, 'Y:_signedness, 'W:_size> \/A:*[X] => ({{Y}} W -`> A) -`> A;  
  inline scott = /\A ### ({{Y}} W -`> A) -`> A => `\f : {{Y}} W -`> A {
	  f `1 : {{Y}} W
  };
  
  inline _ :: <'Y:_signedness, 'W:_size> {{Y}} W;
  inline one = scott[[\/A => ({{Y}} W -`> A) -`> A]]<_> `(`\x => x);
  
  inline constSysF = /\A ### \/B => ![A] -`> ![B] -`> A {
    /\B ### ![A] -`> ![B] -`> A {
      `\![x] => `\![y] => x
    }
  };
  
  inline _ :: <'X:_stage, 'Y:_stage, A:*[X], B:*[Y]> ![A] -`> ![B] -`> A;
  inline const = constSysF[[\/A => \/B => ![A] -`> ![B] -`> A]]<_>[[\/ B => ![A] -`> ![B] -`> A]]<_>;

};
