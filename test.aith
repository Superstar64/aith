module:::

inline runtimeCall = \f => \x => f $ x;

module combinators = {
	inline flip = \f => \x => \y => f `y `x;
	inline compose = \f => \g => \x => f `(g `x);
	
	inline readerPure = \x => \![r] => x;
	inline readerBind = \m => \f => \![r] => f `(m `![r]) `![r];
	inline readerMap = \f => \m => readerBind `m `(compose `readerPure `f);
};

module systemf = {

	inline ignored <B : *> : \/A : * => B -> B;
	inline ignored <B> = /\A : * => \(x : B) => x;

	inline idSysF = /\A : * => \(x : A) => x;

	inline runIdSysF = \f {
		(f : \/A => A -> A)`<_>
	};

	inline id = runIdSysF `idSysF;

	inline constSysF = /\A : * => /\B : * => \![x : A] => \![y : B] => x;

	inline const <A:*, B:*> : ![A] -> ![B] -> A;
	inline const <A,B> = ((constSysF : \/A => \/B => ![A] -> ![B] -> A)`<_> : \/ B => ![A] -> ![B] -> A)`<_>;

};

module varSub = {
	inline sub<A : *, B : * >= A, C:*> : ![A] -> ![B] -> C -> C;
	inline sub<A,B,C> = \![a : A] => \![b : B] => \x => x;


	inline cycle = \![a] => \![b] => \![c] {
		sub `![a] `![b] `(
			sub `![b] `![c] `(
				sub `![c] `![a] `(
					\x => x
				)
			)
		)
	};

	inline rigid<A : * >= (\/B : * => B -> B), C : *> : ![A] -> C -> C;
	inline rigid<A, C> = \![a] => sub `![/\D : * => \y : D => y] `![a];
};

module default = {
	add = function(x,y) {
		x + y
	};

	ambigous = function(x) {
		inline ![y] = ![1];
		x
	};
};

module unit = {
	idUnit = function () {
		()
	};
};

module boolean = {
	inline yes = true;

	branch = function(b) {
		if b {
			1
		} else {
			2
		}
	};

	complex = function(b) {
		if (if (b) { true } else {false} ) {
			1
		} else {
			if yes {
				2
			} else {
				4
			}
		}
	};

	not = function(b) {
		~b
	};

	inBounds = function(x1, x2, x3) {
		x1 <= x2 & x2 < x3
	};
};

module pair = {
	inline fstSysF = /\A : +[pointer] => /\B : +[pointer] if copy => function(x :: A, y :: B) => x;
  
	fst <A : +[pointer], B : +[pointer] if copy, R : region> :  function (A, B) => A uses R;
	fst <A, B, R> = ((fstSysF : \/A => \/B if copy => function (A,B) => A uses R)`<_> : \/B if copy => function(A,B) => A uses R)`<_>;
	
	snd <A : +[pointer] if copy, B : +[pointer], R : region> : function (A, B) => B uses R;
	snd <A,B,R> = function(x, y) => y;
	
	pattern = function (pair) {
		(fst $ pair, snd $ pair)
	};
};

module ptr = {
	derefTriple = function(x) {
		***x
	};

	deref <RA : region, RB : region >= RA, T : +[pointer] if copy > : function (T* @ RA) => T uses RB;
	deref <RA, RB, T if copy> = function (x) {
		*x
	};

	write<A:region, B:region >= A> : function(int* @ A) => () uses B;
	write<A:region, B:region >= A> = function(x :: int* @ A) {
		*x = (1 :: int)
	};

	writeTriple = function(x) {
		***x = 1 
	};

	swap = function(x,y) {
		let xp = *x;
		let () = *x = (*y);
		let () = *y = xp;
		()
	};
};

module integer = {
	dotProduct = function(vector1P, vector2P) {
		let (x1,y1,z1) = *vector1P;
		let (x2,y2,z2) = *vector2P;
		(x1 * x2 + y1 * y2 + z1 * z2)
	};
  
	mid <R : region> : function(uint, uint) => uint uses R;
	mid <R : region> = function(x,y) {
		(x + y) / 2
	};

	inline divGen = function(x,y) {
		(x + y - 1) / y
	};

	div = divGen;

	lessEqual = function(x,y) {
		x <= y
	};

	factorial<R : region> : function(ulong) => ulong uses R; 
	factorial<R : region> = function(x) {
		if (x = 0) {
			1
		} else {
			x * (factorial $ x - 1)  
		}
	};
};

module fptr = {
	call = function(f) {
		f $ 1
	};

	callUnit <R : region> : function(function*(uint) => () uses R) => () uses R;
	callUnit <R : region> = function(f) {
		f $ 2
	};
};

module recurse = {
	explode<R:region, A:+[pointer]> : function() => A uses R;
	explode<R:region, A:+[pointer]> = function() {
		explode $ ()
	};
};

module world = {
	inline putchar<A:region> : function*(int) => int uses io in A;
	inline putchar<A> = extern "putchar";

	putPtr<A:region >= io> : function(int* @ A) => int uses A;
	putPtr<A> = function(ptr) {
		putchar $ *ptr
	};
};

module arrays = {
	inline get = \x => \i {
		*&*(x &+ i)
	};

	inline set = \x => \i => \a {
		*&*(x &+ i) = a
	};

	memcpyPtr <A : +[pointer] if copy, R : region> : function(A[] @ R, A[] @ R, #unsigned native) => () uses R; 
	memcpyPtr <A, R> = function (dst, src, i) {
		if(i != 0) {
			let () = set `dst `0 `(get `src `0);
			memcpyPtr $ (dst &+ 1, src &+ 1, i + 1)
		} else {
			()
		}
	};
};