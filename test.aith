module:

inline runtimeCall = `\f => `\x => f $ x;

module combinators = {
	inline flip = `\f => `\x => `\y => f `y `x;
	inline compose = `\f => `\g => `\x => f `(g `x);
	
	inline readerPure = `\x => `\![r] => x;
	inline readerBind = `\m => `\f => `\![r] => f `(m `![r]) `![r];
	inline readerMap = `\f => `\m => readerBind `m `(compose `readerPure `f);
};


module runtime = {
	import call = /test/runtimeCall;
	
	inline copyFP = _copyFunction;
	inline copyRef = _copyReference;
	inline copyPair = `\x => `\y => _copyPair x y;
	inline copyNum = _copyNumber;
	
	inline _ :: !({{_signed}} _int, {{_signed}} _int, {{_signed}} _int);
  inline copyVector = copyPair `(copyPair `copyNum `copyNum) `copyNum;

  symbol dotProduct = \(vector1P, vector2P) {
    _inline ![c] = ![copyNum];
    _let (!(c)[x1],!(c)[y1],!(c)[z1]) = _read !(copyVector) vector1P;
    _let (!(c)[x2],!(c)[y2],!(c)[z2]) = _read !(copyVector) vector2P;
    (x1 * x2 + y1 * y2 + z1 * z2)
  };
  
	symbol _ :: <A : +[#_pointer#], B : +[#_pointer#], R : _region> !(B) -^> (A, B) -> R A;
	symbol fst = ^\proof => \(x, !(proof)[y]) => x;
	
	symbol _ :: <A : +[#_pointer#], B : +[#_pointer#], R : _region> !(A) -^> (A, B) -> R B;
	symbol snd = ^\proof => \(!(proof)[x], y) => y;
	
  symbol pattern = ^\proof1 => ^\proof2 => \!(copyPair `proof1 `proof2)[pair] {
    (fst ^proof2 $ pair), (snd ^proof1 $ pair)
  };
};


module systemf = {
  inline idSysF = /\A ### (A -`> A) => `\x => x;
  inline runIdSysF = `\f {
    f[[\/A => A -`> A]]<_>
  };
  
  inline id = runIdSysF `idSysF;
  
  inline constSysF = /\A ### \/B => ![A] -`> ![B] -`> A {
    /\B ### ![A] -`> ![B] -`> A {
      `\![x] => `\![y] => x
    }
  };
  
  inline _ :: <'X:_stage, 'Y:_stage, A:*[X], B:*[Y]> ![A] -`> ![B] -`> A;
  inline const = constSysF[[\/A => \/B => ![A] -`> ![B] -`> A]]<_>[[\/ B => ![A] -`> ![B] -`> A]]<_>;

};
