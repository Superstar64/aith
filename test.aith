module:

inline runtimeCall = `\f => `\x => f $ x;

module combinators = {
	inline flip = `\f => `\x => `\y => f `y `x;
	inline compose = `\f => `\g => `\x => f `(g `x);
	
	inline readerPure = `\x => `\![r] => x;
	inline readerBind = `\m => `\f => `\![r] => f `(m `![r]) `![r];
	inline readerMap = `\f => `\m => readerBind `m `(compose `readerPure `f);
};


module run = {
	import call = /test/runtimeCall;
	
	
	inline _ :: !({{signed}} int, {{signed}} int, {{signed}} int);
  inline copyVector = copyPair (copyPair copyNumber copyNumber) copyNumber;

  symbol dotProduct = \(vector1P, vector2P) {
    inline ![c] = ![copyNumber];
    let (!(c)[x1],!(c)[y1],!(c)[z1]) = read !(copyVector) vector1P;
    let (!(c)[x2],!(c)[y2],!(c)[z2]) = read !(copyVector) vector2P;
    (x1 * x2 + y1 * y2 + z1 * z2)
  };
  
  symbol fstSysF = /\A : +[#pointer#] => /\B : +[#pointer#] => ^\(proof : !(B)) => \((x : A), !(proof)[y]) => x;
  
  
	symbol _ :: <A : +[#pointer#], B : +[#pointer#], R : region> !(B) -^> (A, B) -> R A;
	symbol fst = ^\proof => \x => fstSysF[[\/A => \/B => !(B) -^> (A,B) -*> R A @ R]]<_>[[\/B => !(B) -^> (A,B) -*> R A @ R]]<_>^proof $ x;
	
	symbol _ :: <A : +[#pointer#], B : +[#pointer#], R : region> !(A) -^> (A, B) -> R B;
	symbol snd = ^\proof => \(!(proof)[x], y) => y;
	
  symbol pattern = ^\proof1 => ^\proof2 => \!(copyPair proof1 proof2)[pair] {
    (fst ^proof2 $ pair), (snd ^proof1 $ pair)
  };
};


module systemf = {

  inline _ :: <'S : stage, B : *[S]> \/A => B -`> B;
  inline ignored = /\A : *[S] => `\(x : B) => x;
  
  inline idSysF = /\A => `\(x : A) => x;
  
  inline runIdSysF = `\f {
    f[[\/A => A -`> A]]<_>
  };
  
  inline id = runIdSysF `idSysF;
  
  inline constSysF = /\A => /\B => `\![x : A] => `\![y : B] => x;
  
  inline _ :: <'X:stage, 'Y:stage, A:*[X], B:*[Y]> ![A] -`> ![B] -`> A;
  inline const = constSysF[[\/A => \/B => ![A] -`> ![B] -`> A]]<_>[[\/ B => ![A] -`> ![B] -`> A]]<_>;

};
